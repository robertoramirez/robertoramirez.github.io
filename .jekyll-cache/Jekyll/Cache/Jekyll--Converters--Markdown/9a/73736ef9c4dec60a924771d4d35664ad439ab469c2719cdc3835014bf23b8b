I"ﬁ;<p>Sabemos hoy en d√≠a que la mayor√≠a de las empresas basan sus aplicaciones en software analizado, dise√±ado y programado orientado a objetos. Novutek, los √∫ltimos meses se ha preocupado porque que cada vez en los desarrollos que se venden se utilicen objetos para crear modelos de negocio, que con esto, sin duda si creamos un modelo de dominio orientado a objetos ser√° m√°s claro el negocio para que el que lo necesite entender y c√≥digo f√°cil mucho mas mantenible para los programadores que lo vayan a modificar.</p>

<p>Por otro lado tenemos la informaci√≥n, los datos, y probablemente todos nosotros en nuestros desarrollos hemos trabajado con bases de datos relacionales tales como SQL Server, MySQL, entre otras. Esta informaci√≥n seguramente necesitara cambiar e irse modificando, as√≠ como tambi√©n necesitaremos tener esta informaci√≥n disponible cuando queramos, esto en al √°rea de desarrollo de sistemas se le conoce como persistencia. Como se relaciona esto? el modelo relacional de datos es la representaci√≥n m√°s clara de los objetos de negocio que existen en nuestro dominio de sistema y este necesitara almacenar informaci√≥n de cada una de sus entidades dentro del mismo dominio (Clientes, Productos, Usuarios, etc) y al conjuntarse nace un concepto conocido como Object Relational Mapping (ORM).</p>

<p>NHibernate (NH) es un marco de trabajo ORM para ambientes en los que utilizamos .NET que nace de un port de Hibernate de Java y la gran utilidad es que ayuda a mapear los objetos de negocio que creamos en nuestras aplicaciones de .NET a bases de datos relacionales.</p>

<p>A partir de ahora intentaremos explicar c√≥mo funciona a grandes rasgos NH y como podr√≠amos aplicarlo a los nuevos desarrollos en la empresa. Para la pr√°ctica estaremos utilizando la versi√≥n 2008 del Visual Studio Team System (VSTS 2008) como IDE de desarrollo y la versi√≥n express del SQL Server 2005.</p>

<h2 id="1-crear-un-proyecto-biblioteca-de-clases">1. Crear un proyecto biblioteca de clases</h2>

<p>Este proyecto deber√° de contener nuestros objetos de negocio, y por lo tanto aquellos objetos que deseamos persistir. Como ya hemos mencionado en otros tutoriales, se recomienda como buena pr√°ctica crear un archivo de soluci√≥n (sln) y en este agregar tantos proyectos vayamos a necesitar.</p>

<p><img src="/img/14994942-paso1.jpg" /></p>

<p>Para este tutorial he creado un proyecto llamado Tutorial.NH.BOL que es la biblioteca de clases que contendr√° las entidades que representaran la base de datos.</p>

<h2 id="2-crear-modelo">2. Crear modelo</h2>

<p>Nuestro modelo de dominio estar√° basado en usuarios (crearemos una carpeta con nombre Entidades en nuestro proyecto para depositar nuestras clases) y las diversas tareas que puede tener un usuario, sabemos que nuestras aplicaciones empresariales son m√°s complejas, pero creo que bastar√° con explicar lo esencial para entender lo que es NH. La idea de esto es poder persistir estas entidades en nuestra base de datos relacional. Para hacer m√°s sencillo el entendimiento de NH imag√≠nense que una instancia de cada una de nuestras entidades en una fila de una tabla de la base de datos, pero no se casen con este concepto.</p>

<p>Es una buena pr√°ctica usar el diagramador de clases que por defecto cuenta el VSTS 2008, el trabajo es m√°s limpio, mas controlado y lo mejor de todo en la mayor√≠a de los casos ¬°no tenemos que escribir c√≥digo! =).</p>

<p><img src="/img/14994982-paso2.jpg" /></p>

<h2 id="3-crear-modelo-relacional">3. Crear modelo relacional</h2>

<p>El modelo relacional estar√° representado por aquellas tablas de base de datos las cuales deber√°n de representar las entidades del modelo de dominio que queremos persistir. Ya sea en el IDE de VSTS 2008 o en la consola de Microsoft SQL Server deberemos de obtener algo como esto (algo ideal ser√≠a utilizar NH para generar el esquema de nuestra base de datos acorde a nuestro modelo de dominio, este m√©todo queda fuera del alcance del tutorial):</p>

<p><img src="/img/14994961-paso3.jpg" /></p>

<h2 id="4-mapeo-orm">4. Mapeo ORM</h2>

<p>La manera en c√≥mo se mapeara el modelo de dominio con nuestro modelo relacional es a trav√©s de documentos XML, esto se hace con el fin de documentar la relaci√≥n que existe entre nuestro objeto y la tabla que lo representa en la base de datos, es decir, el documento de configuraci√≥n define que campos en la base de datos corresponden a los atributos en nuestro objeto y viceversa. La relaci√≥n puede hacerse mediante c√≥digo (con ayuda de la librer√≠a NHibernate.Mapping.Attributes.dll) en los atributos de la clase √≥ a trav√©s de archivos como los que acabo de comentar, archivos XML que tienen la extensi√≥n .hbm.xml, es por esto que nuestros archivos mapping deberan llamarse Usuario.hbm.xml y Tarea.hbm.xml. No hay que perder de vista que el .hbm es parte del nombre del archivo y es una convenci√≥n que utiliza NH para identificar los archivos como mapping.</p>

<p>Antes de empezar a trabajar con nuestro mapeo ORM debemos de descargar la versi√≥n 1.02 de NHibernate para .NET, la cual est√° disponible en la siguiente direcci√≥n: http://downloads.sourceforge.net/nhibernate/NHibernate-1.2.0.GA-bin.zip?modtime=1178204756&amp;big_mirror=0</p>

<p>Se recomienza habilitar el Intellisense para el mapeo y la creaci√≥n de estos archivos de configuraci√≥n, para esto debemos de copiar los archivos nhibernate-configuration.xsd (para la configuraci√≥n de las sesiones, algo que veremos m√°s adelante en este tutorial) y nhibernate-mapping.xsd (para los mappings) a las carpetas de instalaci√≥n de Visual Studio, &lt;VS .NET directorio de instalaci√≥n&gt;\Common7\Packages\schemas\xml\ si usamos VS.NET 2003 y &lt;VS 2005 installation directory&gt;\Xml\Schemas\ para VS.NET 2005 y 2008.</p>

<p>Dentro de nuestra librer√≠a de clases Tutorial.NH.BOL vamos a crear una carpeta llamada Mapping -esto con el fin de tener mas orden- la cual contendr√° todos nuestros archivos de configuraci√≥n y la implementaci√≥n de estos la muestro a continuaci√≥n:</p>

<h3 id="41-usuariohbmxml">4.1. Usuario.hbm.xml</h3>

<script src="https://gist.github.com/4079649.js?file=gistfile1.xml"></script>

<p>Ahora podemos hablar un poco sobre el contenido del archivo XML. Todos los documentos para mapear XML deber√°n de declarar el espacio de nombre urn:nhibernate-mapping-2.2 (depende de la versi√≥n distribuida), as√≠ como de manera opcional los atributos assembly para indicar el ensamblado de nuestras clases y el namespace de nuestras clases en el proyecto. Existen otros atributos aplicables a nuestro archivo como el schema, que representa el nombre del esquema de la base de datos, entre otros que est√°n fuera del alcance de este tutorial. Una vez hecho esto debemos de comenzar a tratar los atributos y elementos para la clase que deseamos mapear. Dentro de las etiquetas <class name="Usuario"></class> estar√°n todas aquellas configuraciones para la clase. El atributo name corresponde al nombre de la clase incluyendo el nombre del assembly. El atributo table corresponde al nombre de la tabla en la base de datos.</p>

<p>Con la etiqueta <id> representamos la llave primaria de la tabla de la base de datos. Este elemento define el mapeo entre la propiedad de la clase y la llave primaria de la base de datos. Entre sus atributos se encuentra el name, que indica el nombre del identificador de la propiedad; columna, que representa la columna en la tabla; type, el tipo de dato y el unsaved-value indica que el objeto es nuevo y que no existe en la base de datos.</id></p>

<p>Debemos de continuar con todas las propiedades, entonces Nombre, Apellido Paterno, Apellido Materno, Correo Electronico y Telefono deber√°n de estar dentro de las etiquetas <property></property> y representan propiedades persistentes de la clase.</p>

<p>Y como hab√≠amos dicho al inicio del tutorial, lo complicaremos creando una relaci√≥n one-to-many con la clase Tarea y de esta forma representaremos la relaci√≥n en la base de datos, es decir, que a un usuario se le pueden asignar varias tareas.</p>

<h3 id="42-tareahbmxml">4.2. Tarea.hbm.xml</h3>

<script src="https://gist.github.com/4079650.js?file=gistfile1.xml"></script>

<p>Lo √∫nico representativo es el elemento <many-to-one> para la propiedad Usuario de nuestra clase. Esta representa una ordinaria asociaci√≥n a otra clase persistente, en este caso la que tenemos en la base de datos.</many-to-one></p>

<p>Algo que debemos de saber es que en primera instancia NH est√° configurado de modo perezoso (lazy load) para todas las entidades creadas. Esto se recomienda dejarse as√≠ y no moverse. Debido a esto la regla es que todas las propiedades definidas en nuestras entidades deber√°n ser virtuales.</p>

<script src="https://gist.github.com/4079655.js?file=gistfile1.txt"></script>

<p>Hay mucha m√°s informaci√≥n relacionada a estos archivos mapping, pero ser√≠a algo complicado tratar de explic√°rselos paso a paso, adem√°s de que este tutorial perder√≠a sentido, para ello, recomiendo consultar la referencia en l√≠nea sobre este mapeo de clases en http://www.hibernate.org/hib_docs/nhibernate/1.2/reference/en/html/mapping.html.</p>

<p>Hasta aqu√≠ nuestro explorador de soluciones deber√° verse as√≠:</p>

<p><img src="/img/14995032-paso4.jpg" /></p>

<h2 id="5-configurando-nhibernate-en-vsts-2008-net">5. Configurando NHibernate en VSTS 2008 .NET</h2>

<p>Bueno hasta ahora, no hemos hecho mucho, pero ya empieza lo bueno =). Hay que decirle a NH con que proveedor de base de datos vamos a trabajar. Por fortuna NH soporta el m√°s querido por nosotros en la oficina SQL Server.</p>

<p>Para hacer mas modular la aplicaci√≥n, vamos a agregar una aplicaci√≥n de consola a nuestra soluci√≥n con el fin de consumir nuestro ORM. El nombre que yo le he puesto al proyecto es Tutorial.NH.App, tu puedes ponerle el que gustes. Importante agregar dentro de las referencias nuestro ensamblado de nombre Tutorial.NH.BOL. Pudimos haber utilizado Unit Test para probar nuestro proyecto en lugar de la aplicaci√≥n de Consola, pero mejor eso ve√°moslo despu√©s.</p>

<h3 id="51-configuraci√≥n-en-appconfig">5.1. Configuraci√≥n en App.config</h3>

<p>Agregaremos un archivo de configuraci√≥n donde indicaremos las llaves necesarias para establecer la comunicaci√≥n con nuestra base de datos.</p>

<script src="https://gist.github.com/4079657.js?file=gistfile1.xml"></script>

<h3 id="52-configuraci√≥n-en-hibernatecfgxml">5.2 Configuraci√≥n en hibernate.cfg.xml</h3>

<p>Este es otra manera de realizar nuestra configuraci√≥n de NH y consiste en agregar un archivo XML a nuestro proyecto con la siguiente estructura: hibernate.cfg.xml.</p>

<script src="https://gist.github.com/4079650.js?file=gistfile1.xml"></script>

<p>Podemos utilizar cualquiera de los dos. Con este archivo de configuraci√≥n le decimos a NH que queremos trabajar con Microsoft SQL Server como base de datos. Para nuestro ejemplo usaremos la segunda opci√≥n.</p>

<p>Y bien ya estamos listos para iniciar con nuestras operaciones CRUD.</p>

<h2 id="6-operaciones-crud">6. Operaciones CRUD</h2>

<p>Nuestro sistema hasta este punto ha sido preparado con lo esencial. Se han implementado caracter√≠sticas necesarias para el funcionamiento de NH, se ha creado el modelo de dominio se han definido los archivos mapping y se ha establecido la configuraci√≥n a NH. Vamos poco a poco y ya llevamos algo recorrido =).</p>

<p>Empezaremos a darle uso y funcionalidad a nuestro dominio.</p>

<p>Ahora, vamos a agregar una carpeta a nuestro proyecto Tutorial.NH.BOL llamado Repositorio (esto lo especifica Domain Driven Design) y en el agregaremos una clase llamada IRepositorioUsuario.cs y la definimos de la siguiente manera:</p>

<script src="https://gist.github.com/4079659.js?file=gistfile1.cs"></script>

<p>Ahora, lo que sigue es implementar cada uno de los m√©todos definidos por la Interface IRepositorioUsuario.cs. Comenzaremos con el primer m√©todo Agregar() que nos va a permitir agregar una instancia de un Usuario en nuestra base de datos.</p>

<p>Dentro de la misma carpeta (Repositorio) vamos a agregar una clase llamada RepositorioUsuario.cs y vamos a hacer que herede de la interfase IRepositorioUsuario.cs, con esto haremos que la clase implemente cada uno de los m√©todos de la interface.</p>

<script src="https://gist.github.com/4079662.js?file=gistfile1.cs"></script>

<p>Ahora, lo que sigue es crear el mecanismo para crear las sesiones que se van a comunicar con nuestra base de datos. Dentro del mismo proyecto, nos crearemos una Carpeta que nombraremos Genericos y agregamos una clase de nombre NHibernateClass.cs.</p>

<script src="https://gist.github.com/4079664.js?file=gistfile1.cs"></script>

<p>Esta clase lo que har√° por nosotros es crear una SessionFactory solo la primera vez que el cliente necesita una sesi√≥n. Que contiene este Singleton? Contiene un objeto del tipo Configuraci√≥n que utiliza la configuraci√≥n de nuestro hibernate.cfg.xml que creamos en la aplicaci√≥n se escritorio y que se encarga de cargar el objeto ISessionFactory gracias al m√©todo BuildSessionFactory() y de esta forma poder comenzar a crear sesiones de tipo ISessionFactory.</p>

<p>Volvamos a nuestra clase RepositorioUsuario.cs e implementemos el m√©todo Agregar() de la siguiente manera:</p>

<script src="https://gist.github.com/4079665.js?file=gistfile1.txt"></script>

<p>En el m√©todo Actualizar() escribiremos lo siguiente:</p>

<script src="https://gist.github.com/4079667.js?file=gistfile1.txt"></script>

<p>En el m√©todo Eliminar() escribiremos lo siguiente:</p>

<script src="https://gist.github.com/4079670.js?file=gistfile1.txt"></script>

<p>Para el m√©todo ObtenerUsuarioPorId() haremos esto:</p>

<script src="https://gist.github.com/4079673.js?file=gistfile1.txt"></script>

<p>Y para obtener todos los usuarios:</p>

<script src="https://gist.github.com/4079674.js?file=gistfile1.txt"></script>

<p>Nota la creaci√≥n del objeto sesi√≥n desde nuestra clase NHibernateClass.cs y tambien el uso de una transacci√≥n.</p>

<p>¬°Y listo! podemos empezar a trabajar con nuestro modelo de NH para la persistencia de nuestras entidades de dominio.</p>

<p>Para guardar la informaci√≥n de un usuario y sus tareas una posible implementaci√≥n es que desde nuestra aplicaci√≥n de consola incluyamos esta implementaci√≥n:</p>

<script src="https://gist.github.com/4079677.js?file=gistfile1.txt"></script>

<p>Si bien recordamos cuando hicimos el modelo de dominio y las mapeamos con la base de datos, creamos unas propiedades que permit√≠an las relaciones &lt;many-to-one /&gt;, &lt;one-to-many /&gt;. Esta es la verdadera magia, se dieron cuenta que nunca utilizamos procedimientos almacenados? o que nunca nos creamos rutinas de conexi√≥n y de creaci√≥n de DataAdapters? o DataSets? mucho menos DataReaders? Gracias a NH podemos persistir nuestros objetos de una manera limpia y orientada a objetos que es lo m√°s importante.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>En este sencillo ejemplo, pudimos observar c√≥mo manejar un modelo de dominio y como cerrar el ‚Äúgap‚Äù con nuestra base de datos relacional. Sabemos que este es un ejemplo b√°sico y hay mucho m√°s que explicar y que probar, pero por lo pronto espero que esto les haya servido como una introducci√≥n (al menos a m√≠ si me ayudo jeje).</p>
:ET